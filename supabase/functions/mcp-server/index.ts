// =============================================
// LAYER 4: EDGE FUNCTIONS - MCP Server
// Model Context Protocol server for AI agent integration
// =============================================

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
    )

    const { action, params } = await req.json()

    let result
    switch (action) {
      case 'get_production_context':
        result = await getProductionContext(supabaseClient, params)
        break
      case 'create_task':
        result = await createTask(supabaseClient, params)
        break
      case 'update_schedule':
        result = await updateSchedule(supabaseClient, params)
        break
      case 'generate_report':
        result = await generateReport(supabaseClient, params)
        break
      case 'analyze_budget':
        result = await analyzeBudget(supabaseClient, params)
        break
      default:
        throw new Error(`Unknown MCP action: ${action}`)
    }

    return new Response(
      JSON.stringify({ success: true, data: result }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})

// Get complete production context for AI
async function getProductionContext(supabase: any, params: any) {
  const { production_id } = params

  const [production, tasks, events, team, budget] = await Promise.all([
    supabase.from('productions').select('*').eq('id', production_id).single(),
    supabase.from('project_tasks').select('*').eq('production_id', production_id),
    supabase.from('events').select('*').eq('production_id', production_id),
    supabase.from('personnel_assignments').select('*, personnel(*)').eq('production_id', production_id),
    supabase.from('budgets').select('*, budget_line_items(*)').eq('production_id', production_id),
  ])

  return {
    production: production.data,
    tasks: tasks.data,
    events: events.data,
    team: team.data,
    budget: budget.data,
  }
}

// AI-assisted task creation
async function createTask(supabase: any, params: any) {
  const { production_id, workspace_id, task_name, description, due_date, assignee_id } = params

  const { data, error } = await supabase
    .from('project_tasks')
    .insert({
      production_id,
      workspace_id,
      name: task_name,
      description,
      due_date,
      assignee_id,
      status: 'todo',
      created_by: params.created_by || null
    })
    .select()
    .single()

  if (error) throw error
  return data
}

// AI-assisted schedule optimization
async function updateSchedule(supabase: any, params: any) {
  const { event_id, suggested_time, reason } = params

  const { data, error } = await supabase
    .from('events')
    .update({
      start_time: suggested_time.start,
      end_time: suggested_time.end,
    })
    .eq('id', event_id)
    .select()
    .single()

  if (error) throw error

  // Log the AI suggestion
  await supabase.from('activities').insert({
    action: 'ai_schedule_update',
    entity_type: 'event',
    entity_id: event_id,
    metadata: { reason, old_time: params.old_time, new_time: suggested_time }
  })

  return data
}

// AI-powered report generation
async function generateReport(supabase: any, params: any) {
  const { workspace_id, report_type, date_range } = params

  const { data } = await supabase
    .rpc('get_workspace_dashboard', { p_workspace_id: workspace_id })

  // AI would process this data and generate insights
  return {
    report_type,
    date_range,
    data,
    insights: [
      'Generated by AI - would include actual insights here'
    ]
  }
}

// AI budget analysis
async function analyzeBudget(supabase: any, params: any) {
  const { budget_id } = params

  const { data: variance } = await supabase
    .rpc('get_budget_variance', { p_budget_id: budget_id })

  // AI analyzes variances and provides recommendations
  const analysis = {
    total_variance: variance?.reduce((sum: number, item: any) => sum + item.variance, 0),
    high_variance_categories: variance?.filter((item: any) => Math.abs(item.variance_percent) > 10),
    recommendations: [
      'AI-generated budget recommendations would go here'
    ]
  }

  return analysis
}
